-- Delta Executor: Teleport Debug + GUI
-- Dán vào Delta/Executor và chạy

local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local player = Players.LocalPlayer
if not player then
    warn("[TP Debug] Không tìm thấy LocalPlayer — chạy trong môi trường client (Delta)?")
    return
end

-- config
local KEYWORDS = {"checkpoint","cp","spawn","flag","point","marker","pad","finish","goal","teleport","tp"}
local VERIFY_THRESHOLD = 6 -- studs để coi là thành công
local DEFAULT_DELAY = 1.5

-- helper: tìm root part
local function getRootPart(char)
    if not char then return nil end
    local names = {"HumanoidRootPart","LowerTorso","UpperTorso","Torso","RootPart","Head"}
    for _,n in ipairs(names) do
        local p = char:FindFirstChild(n)
        if p and p:IsA("BasePart") then return p end
    end
    if char.PrimaryPart and char.PrimaryPart:IsA("BasePart") then return char.PrimaryPart end
    return char:FindFirstChildWhichIsA("BasePart")
end

-- helper: lấy vị trí từ object (Part/Model/SpawnLocation)
local function getPositionFromObject(obj)
    if not obj then return nil end
    if obj:IsA("BasePart") then
        return obj.Position
    elseif obj:IsA("Model") then
        if obj.PrimaryPart and obj.PrimaryPart:IsA("BasePart") then
            return obj.PrimaryPart.Position
        else
            local p = obj:FindFirstChildWhichIsA("BasePart")
            if p then return p.Position end
        end
    end
    return nil
end

-- scan workspace + collection tags
local function scanCandidates()
    local seen = {}
    local out = {}

    -- scan CollectionService tags (nếu server có tag "Checkpoint")
    local ok, tagged = pcall(function() return CollectionService:GetTagged("Checkpoint") end)
    if ok and tagged then
        for _, t in ipairs(tagged) do
            if t and not seen[t] then
                local pos = getPositionFromObject(t)
                if pos then
                    seen[t] = true
                    table.insert(out, {obj=t, pos=pos})
                end
            end
        end
    end

    -- scan workspace descendants
    for _, obj in ipairs(workspace:GetDescendants()) do
        if not seen[obj] then
            -- include if BasePart OR Model with a BasePart
            local pos = getPositionFromObject(obj)
            local name = obj.Name and obj.Name:lower() or ""
            local matched = false
            -- match by keyword list OR class types like SpawnLocation
            if pos then
                for _, kw in ipairs(KEYWORDS) do
                    if string.find(name, kw, 1, true) then
                        matched = true
                        break
                    end
                end
                if obj:IsA("SpawnLocation") then matched = true end
            end
            if matched then
                seen[obj] = true
                table.insert(out, {obj=obj, pos=pos})
            end
        end
    end

    return out
end

-- sort by numeric suffix if exists, else by name
local function sortCandidates(list)
    table.sort(list, function(a,b)
        local na = tonumber(a.obj.Name:match("%d+")) or math.huge
        local nb = tonumber(b.obj.Name:match("%d+")) or math.huge
        if na ~= nb then return na < nb end
        return a.obj.Name < b.obj.Name
    end)
end

-- teleport attempts (multiple methods)
local function tryTeleportTo(pos)
    local char = player.Character or player.CharacterAdded:Wait()
    local rp = getRootPart(char)
    if not rp then return false, "NoRootPart" end

    local targetCFrame = CFrame.new(pos + Vector3.new(0,3,0))
    local methods = {
        function()
            -- direct set
            rp.CFrame = targetCFrame
        end,
        function()
            -- SetPrimaryPartCFrame
            if char.PrimaryPart then
                char:SetPrimaryPartCFrame(targetCFrame)
            end
        end,
        function()
        
