-- Tele theo thứ tự, auto scan, nhiều fallback method, có debug prints
-- Chạy trong Delta Executor

-- ====== CẤU HÌNH ======
local KEYWORD = "checkpoint"      -- từ khoá để tìm checkpoint (hiệu chỉnh nếu game dùng tên khác, ví dụ "cp" hoặc "CheckPoint")
local DELAY = 2                   -- giây dừng giữa mỗi teleport
local ONE_LOOP = false            -- true = chỉ chạy 1 lần qua tất cả checkpoint, false = lặp vô hạn
local MAX_RETRIES = 3             -- số lần thử mỗi checkpoint
local VERIFY_THRESHOLD = 5        -- nếu cách <= 5 studs coi là thành công
-- =======================

local Players = game:GetService("Players")
local player = Players.LocalPlayer
if not player then
    warn("[TP] Không tìm thấy LocalPlayer. Chạy trong Delta Executor?")
    return
end

local function waitForCharacter()
    local char = player.Character or player.CharacterAdded:Wait()
    -- chờ 1s để các part tồn tại
    task.wait(0.2)
    return char
end

local character = waitForCharacter()

local function getRootPart(chr)
    if not chr then return nil end
    local names = {"HumanoidRootPart", "LowerTorso", "UpperTorso", "Torso", "RootPart", "Head"}
    for _,n in ipairs(names) do
        local p = chr:FindFirstChild(n)
        if p and p:IsA("BasePart") then return p end
    end
    if chr.PrimaryPart and chr.PrimaryPart:IsA("BasePart") then
        return chr.PrimaryPart
    end
    -- fallback: tìm phần đầu tiên là BasePart
    local part = chr:FindFirstChildWhichIsA("BasePart")
    return part
end

local function getPositionFromObject(obj)
    if not obj then return nil end
    if obj:IsA("BasePart") then
        return obj.Position
    elseif obj:IsA("Model") then
        if obj.PrimaryPart and obj.PrimaryPart:IsA("BasePart") then
            return obj.PrimaryPart.Position
        else
            local p = obj:FindFirstChildWhichIsA("BasePart")
            if p then return p.Position end
        end
    end
    return nil
end

local function scanCheckpoints(keyword)
    local out = {}
    local kw = keyword:lower()
    for _,obj in ipairs(workspace:GetDescendants()) do
        if obj.Name and string.find(obj.Name:lower(), kw, 1, true) then
            local pos = getPositionFromObject(obj)
            if pos then
                table.insert(out, {obj = obj, pos = pos})
            end
        end
    end
    return out
end

local function sortCheckpoints(list)
    table.sort(list, function(a,b)
        local na = tonumber(a.obj.Name:match("%d+")) or math.huge
        local nb = tonumber(b.obj.Name:match("%d+")) or math.huge
        if na ~= nb then return na < nb end
        return a.obj.Name < b.obj.Name
    end)
end

local function currentPosition()
    local rp = getRootPart(character)
    if rp then return rp.Position end
    return nil
end

local function tryTeleportOnce(targetPos)
    local rp = getRootPart(character)
    if not rp then
        warn("[TP] Không tìm thấy root part của character.")
        return false
    end

    local targetCFrame = CFrame.new(targetPos + Vector3.new(0, 3, 0))
    local methods = {
        function()
            -- direct set HRP.CFrame
            rp.CFrame = targetCFrame
        end,
        function()
            -- Model:SetPrimaryPartCFrame nếu có
            if character.PrimaryPart then
                character:SetPrimaryPartCFrame(targetCFrame)
            end
        end,
        function()
            -- PivotTo (fallback)
            if character.PivotTo then
                character:PivotTo(targetCFrame)
            else
                -- Model method
                if character:IsA("Model") and character:FindFirstChildWhichIsA("BasePart") then
                    pcall(function()
                        character:PivotTo(targetCFrame)
                    end)
                end
            end
        end,
        function()
            -- fallback: set Position (may error in some
